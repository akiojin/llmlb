//! REST APIハンドラー
//!
//! ノード登録、ヘルスチェック、プロキシAPI

pub mod api_keys;
pub mod audio;
pub mod auth;
pub mod benchmarks;
pub mod cloud_models;
pub mod dashboard;
pub mod dashboard_ws;
/// エンドポイント管理API
pub mod endpoints;
/// APIエラーレスポンス型
pub mod error;
pub mod health;
pub mod images;
pub mod invitations;
pub mod logs;
/// モデル名のパース（量子化サフィックス対応）
pub mod model_name;
pub mod models;
pub mod openai;
pub mod proxy;
/// Open Responses API (SPEC-0f1de549)
pub mod responses;
/// System API (self-update)
pub mod system;
pub mod users;

use crate::cloud_metrics;
use crate::common::auth::{ApiKeyPermission, UserRole};
use crate::AppState;
use axum::{
    body::Body,
    extract::DefaultBodyLimit,
    extract::Path as AxumPath,
    http::{header, StatusCode},
    middleware,
    response::{IntoResponse, Response},
    routing::{delete, get, post, put},
    Router,
};
use include_dir::{include_dir, Dir, File};
use mime_guess::MimeGuess;

static DASHBOARD_ASSETS: Dir = include_dir!("$CARGO_MANIFEST_DIR/src/web/static");
const DASHBOARD_INDEX: &str = "index.html";
const OPENAI_BODY_LIMIT_BYTES: usize = 20 * 1024 * 1024;
// NOTE: Playground機能は廃止され、ダッシュボード内のエンドポイント別Playgroundに移行
// const PLAYGROUND_INDEX: &str = "playground.html";
// Force rebuild when embedded dashboard/playground assets change.
// The file is generated by `llmlb/build.rs`.
const _DASHBOARD_ASSETS_BUILD_STAMP: &str = include_str!(concat!(
    env!("OUT_DIR"),
    "/dashboard_assets_build_stamp.txt"
));

/// APIllmlbを作成
#[allow(deprecated)] // NodeRegistry migration in progress - legacy APIs still registered
pub fn create_app(state: AppState) -> Router {
    let auth_disabled = crate::config::is_auth_disabled();

    // `/api/*`: llmlb独自API（管理/運用向け）
    // JWTが必要な認証ルート（ログイン以外）
    let auth_routes = Router::new()
        .route("/auth/me", get(auth::me))
        .route("/auth/logout", post(auth::logout));

    let auth_routes = if auth_disabled {
        auth_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        auth_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.jwt_secret.clone(),
                crate::auth::middleware::jwt_auth_middleware,
            ))
    };

    // 管理系API（運用/自動化向け）
    //
    // 許可される認証:
    // - JWT (admin role)
    // - APIキー (必要な permissions を保有)
    //
    // NOTE: /api/dashboard/* は管理UI向けのため JWT のみ（APIキー不可）
    let users_routes = Router::new()
        .route("/users", get(users::list_users).post(users::create_user))
        .route(
            "/users/{id}",
            put(users::update_user).delete(users::delete_user),
        );
    let users_routes = if auth_disabled {
        users_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::UsersManage,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        users_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    // ユーザー自身のAPIキー管理（JWTのみ）
    let my_api_keys_routes = Router::new()
        .route(
            "/me/api-keys",
            get(api_keys::list_api_keys).post(api_keys::create_api_key),
        )
        .route(
            "/me/api-keys/{id}",
            put(api_keys::update_api_key).delete(api_keys::delete_api_key),
        );
    let my_api_keys_routes = if auth_disabled {
        my_api_keys_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        my_api_keys_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.jwt_secret.clone(),
                crate::auth::middleware::jwt_auth_middleware,
            ))
    };

    let invitations_routes = Router::new()
        .route(
            "/invitations",
            get(invitations::list_invitations).post(invitations::create_invitation),
        )
        .route("/invitations/{id}", delete(invitations::revoke_invitation));
    let invitations_routes = if auth_disabled {
        invitations_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::InvitationsManage,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        invitations_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    // ノードログ取得（lb→node proxy）
    let node_logs_routes = Router::new().route("/nodes/{node_id}/logs", get(logs::get_node_logs));
    let node_logs_routes = if auth_disabled {
        node_logs_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::LogsRead,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        node_logs_routes.layer(middleware::from_fn_with_state(
            cfg,
            crate::auth::middleware::jwt_or_api_key_permission_middleware,
        ))
    };

    // モデル管理API (Admin のみ: register/delete)
    let models_manage_routes = Router::new()
        .route("/models/register", post(models::register_model))
        .route("/models/{*model_name}", delete(models::delete_model));
    let models_manage_routes = if auth_disabled {
        models_manage_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::ModelsManage,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        models_manage_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    // Prometheus metrics（cloud prefix含む独自メトリクス）
    let metrics_routes = Router::new().route("/metrics/cloud", get(cloud_metrics::export_metrics));
    let metrics_routes = if auth_disabled {
        metrics_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::MetricsRead,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        metrics_routes.layer(middleware::from_fn_with_state(
            cfg,
            crate::auth::middleware::jwt_or_api_key_permission_middleware,
        ))
    };

    let admin_routes = Router::new()
        .merge(users_routes)
        .merge(my_api_keys_routes)
        .merge(invitations_routes)
        .merge(node_logs_routes)
        .merge(models_manage_routes)
        .merge(metrics_routes);

    // ダッシュボードAPI（管理UI向け。JWTのみ）
    let dashboard_api_routes = Router::new()
        .route("/dashboard/endpoints", get(dashboard::get_endpoints))
        .route("/dashboard/models", get(dashboard::get_models))
        .route("/dashboard/stats", get(dashboard::get_stats))
        .route(
            "/dashboard/request-history",
            get(dashboard::get_request_history),
        )
        .route("/dashboard/overview", get(dashboard::get_overview))
        .route(
            "/dashboard/metrics/{node_id}",
            get(dashboard::get_node_metrics),
        )
        .route(
            "/dashboard/request-responses",
            get(dashboard::list_request_responses),
        )
        .route(
            "/dashboard/request-responses/{id}",
            get(dashboard::get_request_response_detail),
        )
        .route(
            "/dashboard/request-responses/export",
            get(dashboard::export_request_responses),
        )
        // トークン統計API
        .route("/dashboard/stats/tokens", get(dashboard::get_token_stats))
        .route(
            "/dashboard/stats/tokens/daily",
            get(dashboard::get_daily_token_stats),
        )
        .route(
            "/dashboard/stats/tokens/monthly",
            get(dashboard::get_monthly_token_stats),
        )
        .route("/dashboard/logs/lb", get(logs::get_lb_logs))
        // モデル別リクエスト統計（全エンドポイント横断）
        .route(
            "/dashboard/model-stats",
            get(dashboard::get_all_model_stats),
        )
        // SPEC-62ac4b68: Clients分析API
        .route("/benchmarks/tps", post(benchmarks::start_tps_benchmark))
        .route(
            "/benchmarks/tps/{run_id}",
            get(benchmarks::get_tps_benchmark),
        )
        .route("/dashboard/clients", get(dashboard::get_client_rankings))
        .route(
            "/dashboard/clients/timeline",
            get(dashboard::get_client_timeline),
        )
        .route(
            "/dashboard/clients/models",
            get(dashboard::get_client_models),
        )
        .route(
            "/dashboard/clients/heatmap",
            get(dashboard::get_client_heatmap),
        )
        .route(
            "/dashboard/clients/{ip}/detail",
            get(dashboard::get_client_detail),
        )
        .route(
            "/dashboard/clients/{ip}/api-keys",
            get(dashboard::get_client_api_keys),
        )
        // SPEC-62ac4b68: 設定API（閾値設定等）
        .route(
            "/dashboard/settings/{key}",
            get(dashboard::get_setting).put(dashboard::update_setting),
        );

    let dashboard_api_routes = if auth_disabled {
        dashboard_api_routes
    } else {
        dashboard_api_routes.layer(middleware::from_fn_with_state(
            state.jwt_secret.clone(),
            crate::auth::middleware::jwt_auth_middleware,
        ))
    };

    // システムAPI（更新状態/適用）
    let system_routes = Router::new()
        .route("/system", get(system::get_system))
        .route("/system/update/check", post(system::check_update))
        .route("/system/update/apply", post(system::apply_update))
        .route(
            "/system/update/apply/force",
            post(system::apply_force_update),
        );
    let system_routes = if auth_disabled {
        system_routes
    } else {
        system_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.jwt_secret.clone(),
                crate::auth::middleware::jwt_auth_middleware,
            ))
    };

    // エンドポイント管理API（SPEC-e8e9326e）
    // READ: endpoints.read
    // WRITE: endpoints.manage (JWTはadminのみ)
    let endpoint_read_routes = Router::new()
        .route("/endpoints", get(endpoints::list_endpoints))
        .route("/endpoints/{id}", get(endpoints::get_endpoint))
        .route(
            "/endpoints/{id}/models",
            get(endpoints::list_endpoint_models),
        )
        .route(
            "/endpoints/{id}/download/progress",
            get(endpoints::download_progress),
        )
        .route(
            "/endpoints/{id}/models/{model}/info",
            get(endpoints::get_model_info),
        )
        // SPEC-8c32349f: エンドポイント単位リクエスト統計
        .route(
            "/endpoints/{id}/today-stats",
            get(dashboard::get_endpoint_today_stats),
        )
        .route(
            "/endpoints/{id}/daily-stats",
            get(dashboard::get_endpoint_daily_stats),
        )
        .route(
            "/endpoints/{id}/model-stats",
            get(dashboard::get_endpoint_model_stats),
        )
        // SPEC-4bb5b55f: エンドポイント×モデル単位TPS
        .route(
            "/endpoints/{id}/model-tps",
            get(dashboard::get_endpoint_model_tps),
        );
    let endpoint_read_routes = if auth_disabled {
        endpoint_read_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::EndpointsRead,
            jwt_required_role: None,
            api_key_role: UserRole::Viewer,
        };
        endpoint_read_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    let endpoint_manage_routes = Router::new()
        .route("/endpoints", post(endpoints::create_endpoint))
        .route(
            "/endpoints/{id}",
            put(endpoints::update_endpoint).delete(endpoints::delete_endpoint),
        )
        .route("/endpoints/{id}/test", post(endpoints::test_endpoint))
        .route(
            "/endpoints/{id}/sync",
            post(endpoints::sync_endpoint_models),
        )
        // SPEC-e8e9326e: ダウンロードAPI
        .route("/endpoints/{id}/download", post(endpoints::download_model));

    let endpoint_manage_routes = if auth_disabled {
        endpoint_manage_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::EndpointsManage,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Admin,
        };
        endpoint_manage_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    let endpoint_routes = Router::new()
        .merge(endpoint_read_routes)
        .merge(endpoint_manage_routes);

    // Playground用プロキシ（JWT認証のみ、APIキー不可）
    // ダッシュボードにログインしているユーザーのみがエンドポイントに直接リクエストを転送できる
    let playground_proxy_routes = Router::new().route(
        "/endpoints/{id}/chat/completions",
        post(endpoints::proxy_chat_completions),
    );

    let playground_proxy_routes = if auth_disabled {
        playground_proxy_routes.layer(middleware::from_fn_with_state(
            state.clone(),
            crate::auth::middleware::inject_dummy_admin_claims_with_state,
        ))
    } else {
        playground_proxy_routes
            .layer(middleware::from_fn(
                crate::auth::middleware::csrf_protect_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.jwt_secret.clone(),
                crate::auth::middleware::jwt_auth_middleware,
            ))
    };
    // Treat dashboard playground proxy as inference for drain purposes.
    let playground_proxy_routes = playground_proxy_routes.layer(middleware::from_fn_with_state(
        state.inference_gate.clone(),
        crate::inference_gate::inference_gate_middleware,
    ));

    // モデル配布レジストリ（registry.read が必要）
    // SPEC-e8e9326e: POST /api/nodes（ノード自己登録）は廃止されました
    // 新しい実装は POST /api/endpoints を使用してください
    let model_registry_routes = Router::new()
        // モデル配布レジストリ（複数ファイル: safetensors 等）
        .route(
            "/models/registry/{model_name}/manifest.json",
            get(models::get_model_registry_manifest),
        );

    let model_registry_routes = if auth_disabled {
        model_registry_routes
    } else {
        model_registry_routes
            .layer(middleware::from_fn_with_state(
                ApiKeyPermission::RegistryRead,
                crate::auth::middleware::require_api_key_permission_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.db_pool.clone(),
                crate::auth::middleware::api_key_auth_middleware,
            ))
    };

    // モデル一覧API (Admin OR Runtime スコープで利用可能)
    // /api/models はランタイム同期用の登録済みモデル一覧
    // /api/models/hub はダッシュボード向けの対応モデル一覧 + ステータス
    let models_list_routes = if auth_disabled {
        Router::new()
            .route("/models", get(models::list_models))
            .route("/models/hub", get(models::list_models_with_status))
    } else {
        let cfg = crate::auth::middleware::JwtOrApiKeyPermissionConfig {
            app_state: state.clone(),
            required_permission: ApiKeyPermission::RegistryRead,
            jwt_required_role: Some(UserRole::Admin),
            api_key_role: UserRole::Viewer,
        };
        Router::new()
            .route("/models", get(models::list_models))
            .route("/models/hub", get(models::list_models_with_status))
            .layer(middleware::from_fn_with_state(
                cfg,
                crate::auth::middleware::jwt_or_api_key_permission_middleware,
            ))
    };

    // SPEC-e8e9326e: POST /api/health（プッシュ型ヘルスチェック）は廃止されました
    // 新しいエンドポイントはプル型ヘルスチェック（EndpointHealthChecker）を使用

    // APIキー認証が必要なルート（OpenAI互換の推論エンドポイント）
    let inference_routes = Router::new()
        .route("/v1/chat/completions", post(openai::chat_completions))
        .route("/v1/completions", post(openai::completions))
        .route("/v1/embeddings", post(openai::embeddings))
        // Open Responses API（SPEC-0f1de549）
        .route("/v1/responses", post(responses::post_responses))
        // 音声API（OpenAI Audio API互換）
        .route("/v1/audio/transcriptions", post(audio::transcriptions))
        .route("/v1/audio/speech", post(audio::speech))
        // 画像API（OpenAI Images API互換）
        .route("/v1/images/generations", post(images::generations))
        .route("/v1/images/edits", post(images::edits))
        .route("/v1/images/variations", post(images::variations))
        .layer(DefaultBodyLimit::max(OPENAI_BODY_LIMIT_BYTES));

    let inference_routes = if auth_disabled {
        inference_routes
    } else {
        inference_routes
            .layer(middleware::from_fn_with_state(
                ApiKeyPermission::OpenaiInference,
                crate::auth::middleware::require_api_key_permission_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.db_pool.clone(),
                crate::auth::middleware::api_key_auth_middleware,
            ))
    };
    // Self-update drain gate: reject new inference requests and track in-flight requests.
    let inference_routes = inference_routes.layer(middleware::from_fn_with_state(
        state.inference_gate.clone(),
        crate::inference_gate::inference_gate_middleware,
    ));

    // `/v1/models*` は外部クライアント(APIキー)からのみ参照される
    // SPEC-e8e9326e: ノードトークン認証は廃止されました
    let models_routes = Router::new()
        .route("/v1/models", get(openai::list_models))
        .route("/v1/models/{model_id}", get(openai::get_model));

    let models_protected_routes = if auth_disabled {
        models_routes
    } else {
        models_routes
            .layer(middleware::from_fn_with_state(
                ApiKeyPermission::OpenaiModelsRead,
                crate::auth::middleware::require_api_key_permission_middleware,
            ))
            .layer(middleware::from_fn_with_state(
                state.db_pool.clone(),
                crate::auth::middleware::api_key_auth_middleware,
            ))
    };

    // NOTE: /api/models (GET) は Admin/Node スコープ共用。
    // 外部クライアントは /v1/models を使用してください（Azure OpenAI 形式の capabilities 付き）。

    // SPEC-e8e9326e: テスト用内部エンドポイント（デバッグビルドのみ）
    // NOTE: ノード登録ベースのテストは廃止。エンドポイント登録を使用
    let test_routes = Router::new();

    let api_routes = Router::new()
        // 認証不要エンドポイント
        .route("/version", get(system::get_version))
        // 認証エンドポイント（ログインは認証不要）
        .route("/auth/login", post(auth::login))
        .route("/auth/register", post(auth::register))
        .merge(auth_routes)
        .merge(system_routes)
        .merge(dashboard_api_routes)
        .merge(admin_routes)
        .merge(endpoint_routes)
        .merge(playground_proxy_routes)
        .merge(model_registry_routes)
        .merge(models_list_routes)
        // デバッグ用テストエンドポイント
        .merge(test_routes);

    let dashboard_routes = Router::new()
        .route("/dashboard", get(serve_dashboard_index))
        .route("/dashboard/", get(serve_dashboard_index))
        .route("/dashboard/{*path}", get(serve_dashboard_asset));

    let ws_routes = Router::new().route("/ws/dashboard", get(dashboard_ws::dashboard_ws_handler));

    Router::new()
        // `/api/*`: llmlb独自API（互換不要・versioned）
        .nest("/api", api_routes)
        // OpenAI互換API
        .merge(inference_routes)
        .merge(models_protected_routes)
        .merge(dashboard_routes)
        // NOTE: Playground機能は廃止され、ダッシュボード内のエンドポイント別Playgroundに移行
        // /playground/* ルートは削除済み
        .merge(ws_routes)
        .fallback(|| async { StatusCode::NOT_FOUND })
        .with_state(state)
}

async fn serve_dashboard_index() -> Response {
    embedded_dashboard_response(DASHBOARD_INDEX)
}

async fn serve_dashboard_asset(AxumPath(request_path): AxumPath<String>) -> Response {
    let normalized = normalize_dashboard_path(&request_path);
    match normalized {
        Some(path) => embedded_dashboard_response(&path),
        None => StatusCode::NOT_FOUND.into_response(),
    }
}

fn embedded_dashboard_response(path: &str) -> Response {
    match DASHBOARD_ASSETS.get_file(path) {
        Some(file) => file_response(file),
        None => StatusCode::NOT_FOUND.into_response(),
    }
}

fn file_response(file: &File<'_>) -> Response {
    let mime = MimeGuess::from_path(file.path())
        .first_or_octet_stream()
        .to_string();
    Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, mime)
        .body(Body::from(file.contents().to_vec()))
        .expect("failed to build embedded dashboard response")
}

fn normalize_dashboard_path(request_path: &str) -> Option<String> {
    let trimmed = request_path.trim_matches('/');
    if trimmed.is_empty() {
        return Some(DASHBOARD_INDEX.to_string());
    }
    if trimmed.contains("..") || trimmed.contains('\\') {
        return None;
    }
    Some(trimmed.to_string())
}

#[cfg(test)]
mod tests {
    //! NOTE: NodeRegistry廃止（SPEC-e8e9326e）に伴い、EndpointRegistryベースに更新済み。
    //! NodeRegistry.register()を使用していたテストは#[ignore]でマーク。

    use super::*;
    use crate::balancer::LoadManager;
    use axum::body::{to_bytes, Body};
    use axum::http::{Request, StatusCode};
    use std::sync::Arc;
    use tower::Service;

    async fn test_state() -> AppState {
        let db_pool = sqlx::SqlitePool::connect("sqlite::memory:")
            .await
            .expect("Failed to create test database");
        sqlx::migrate!("./migrations")
            .run(&db_pool)
            .await
            .expect("Failed to run migrations");
        let endpoint_registry = crate::registry::endpoints::EndpointRegistry::new(db_pool.clone())
            .await
            .expect("Failed to create endpoint registry");
        let load_manager = LoadManager::new(Arc::new(endpoint_registry.clone()));
        let request_history = std::sync::Arc::new(
            crate::db::request_history::RequestHistoryStorage::new(db_pool.clone()),
        );
        let jwt_secret = "test-secret".to_string();
        let http_client = reqwest::Client::new();
        let inference_gate = crate::inference_gate::InferenceGate::default();
        let shutdown = crate::shutdown::ShutdownController::default();
        let update_manager = crate::update::UpdateManager::new(
            http_client.clone(),
            inference_gate.clone(),
            shutdown.clone(),
        )
        .expect("Failed to create update manager");
        AppState {
            load_manager,
            request_history,
            db_pool,
            jwt_secret,
            http_client,
            queue_config: crate::config::QueueConfig::from_env(),
            event_bus: crate::events::create_shared_event_bus(),
            endpoint_registry,
            inference_gate,
            shutdown,
            update_manager,
        }
    }

    #[tokio::test]
    async fn test_dashboard_static_served() {
        let state = test_state().await;
        let mut app = create_app(state);
        let response = app
            .call(
                Request::builder()
                    .method(axum::http::Method::GET)
                    .uri("/dashboard/index.html")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        let status = response.status();
        let (parts, body) = response.into_parts();
        let bytes = to_bytes(body, 1024 * 1024).await.unwrap();

        assert_eq!(status, StatusCode::OK);
        let content_type = parts.headers[axum::http::header::CONTENT_TYPE]
            .to_str()
            .unwrap();
        assert!(content_type.starts_with("text/html"));
        assert!(bytes.starts_with(b"<!DOCTYPE html"));
    }

    // NOTE: test_playground_static_served は廃止
    // Playground機能はダッシュボード内のエンドポイント別Playgroundに移行 (#playground/:endpointId)

    /// NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)
    #[tokio::test]
    #[ignore = "NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)"]
    async fn test_dashboard_nodes_endpoint_returns_json() {
        let state = test_state().await;
        let mut app = create_app(state);
        let response = app
            .call(
                Request::builder()
                    .method(axum::http::Method::GET)
                    .uri("/api/dashboard/endpoints")
                    .header("x-api-key", "sk_debug")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }

    /// NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)
    #[tokio::test]
    #[ignore = "NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)"]
    async fn test_dashboard_overview_endpoint_returns_all_sections() {
        let state = test_state().await;
        let mut app = create_app(state);
        let response = app
            .call(
                Request::builder()
                    .method(axum::http::Method::GET)
                    .uri("/api/dashboard/overview")
                    .header("x-api-key", "sk_debug")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }

    /// NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)
    #[tokio::test]
    #[ignore = "NodeRegistry廃止: EndpointRegistry経由のテストに移行が必要 (SPEC-e8e9326e)"]
    async fn test_dashboard_metrics_endpoint_returns_history() {
        let state = test_state().await;
        let mut app = create_app(state);
        let response = app
            .call(
                Request::builder()
                    .method(axum::http::Method::GET)
                    .uri("/api/dashboard/request-history")
                    .header("x-api-key", "sk_debug")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }
}
