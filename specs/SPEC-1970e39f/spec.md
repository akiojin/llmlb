# 機能仕様書: 構造化ロギング強化

**機能ID**: `SPEC-1970e39f`
**作成日**: 2025-12-18
**ステータス**: 作成中
**入力**: ユーザー説明: "ルーターとノードのHTTPリクエスト/レスポンスを構造化ログとして
出力し、デバッグと監視を容易にする。既存のtracing(Rust)/spdlog(C++)を活用する"

## ユーザーシナリオ&テスト *(必須)*

### ユーザーストーリー1 - APIリクエストのトレース (優先度: P1)

開発者として、Playground等からのAPIリクエストがどこで失敗したかを
即座に特定したい。ログにリクエストID、エンドポイント、モデル名、ノード情報が
含まれることで、問題の切り分けが容易になる。

**この優先度の理由**: 現在、リクエスト失敗時にログが出力されず、原因特定が困難。
これが解消されればデバッグ効率が大幅に向上する。

**独立テスト**: `/v1/chat/completions`にリクエストを送信し、ルーターのログに
リクエスト受信、ノード選択、プロキシ送信、レスポンス返却の各ステップが
タイムスタンプ付きで記録されることを確認する。

**受け入れシナリオ**:

1. **前提** ルーターが稼働中、**実行** chat completionsリクエストを送信、
   **結果** ログに `endpoint=/v1/chat/completions, model=xxx, request_id=uuid` が出力
2. **前提** ノードが利用不可、**実行** リクエストを送信、**結果**
   ログに `error=NoNodesAvailable, request_id=uuid` が出力され、履歴にも保存
3. **前提** ノードがエラーを返す、**実行** リクエストを送信、**結果**
   ログに `node_id=xxx, status=500, error_message=...` が出力

---

### ユーザーストーリー2 - ノード側の推論ログ (優先度: P2)

運用者として、ノードでの推論処理の詳細（モデルロード、トークン化、生成）を
ログで確認したい。パフォーマンス問題やモデルエラーの診断に役立つ。

**この優先度の理由**: ノード側は既にspdlogでログ出力しているが、一貫性のある
フォーマットと適切なログレベルの見直しが必要。

**独立テスト**: 推論リクエストを送信し、ノードのログに処理時間、
トークン数、生成結果のサマリーが出力されることを確認する。

**受け入れシナリオ**:

1. **前提** ノードが稼働中、**実行** 推論リクエストを送信、**結果**
   ログに `model_loaded=true, prompt_tokens=N, generated_tokens=M, duration_ms=X` が出力
2. **前提** モデルファイルが見つからない、**実行** リクエストを送信、**結果**
   ログに `error=model_not_found, model=xxx, search_path=...` が出力

---

### ユーザーストーリー3 - ログの検索と分析 (優先度: P3)

管理者として、JSON形式のログをjq等のツールで検索・集計したい。
構造化されたログにより、エラー率の算出やレスポンスタイム分析が可能になる。

**この優先度の理由**: 既にJSON出力は実装済み。フィールドの標準化と
ドキュメント化が主な作業。

**独立テスト**: ログファイルを `jq '.level == "error"'` でフィルタし、
エラーログのみが抽出されることを確認する。

**受け入れシナリオ**:

1. **前提** 複数のリクエストが処理済み、**実行** `jq` でログをフィルタ、
   **結果** 条件に一致するログエントリのみが出力される
2. **前提** エラーと成功の両方が存在、**実行** エラー率を算出、
   **結果** `jq` で正確なエラー数と成功数を集計できる

---

### エッジケース

- ストリーミングレスポンスの場合、どのタイミングでログを出力するか？
  - ストリーム開始時とストリーム完了時の2回出力
- 大量のリクエストが同時に発生した場合、ログのパフォーマンスへの影響は？
  - 非同期ログ出力により、リクエスト処理への影響を最小化
  - `tracing-appender`/`spdlog`の非同期モードを活用
- 機密情報（APIキー、プロンプト内容）のログ出力方針は？
  - APIキーはマスク（最初4文字のみ表示）
  - プロンプトはデフォルトでログ出力しない（debug レベルのみ）

## 要件 *(必須)*

### 機能要件

- **FR-001**: ルーターは全てのOpenAI互換APIリクエストの受信をINFOレベルで
  ログ出力する必要がある（request_id, endpoint, model, client_ip）
- **FR-002**: ルーターはノード選択結果をINFOレベルでログ出力する必要がある
  （node_id, node_ip, selection_reason）
- **FR-003**: ルーターはプロキシエラーをWARN/ERRORレベルでログ出力する
  必要がある（error_type, error_message, node_id）
- **FR-004**: ルーターはノード選択失敗時もリクエスト履歴に記録する必要がある
- **FR-005**: ノードは推論リクエストの開始/完了をINFOレベルでログ出力する
  必要がある（model, prompt_tokens, generated_tokens, duration_ms）
- **FR-006**: ノードはモデルロード/アンロードをINFOレベルでログ出力する
  必要がある（model_path, memory_bytes, gpu_layers）
- **FR-007**: 全てのログは構造化JSON形式で出力される必要がある
- **FR-008**: ログファイルは日次ローテーションされる必要がある
- **FR-009**: 7日以上前のログファイルは自動削除される必要がある

### 非機能要件

- **NFR-001**: ログ出力によるリクエストレイテンシ増加は1ms以下であること
- **NFR-002**: ログ出力は非同期で行われ、リクエスト処理をブロックしないこと

### 主要エンティティ

- **ログエントリ**: 1つのログイベントを表す。以下の共通フィールドを含む:
  - タイムスタンプ（ISO 8601形式）
  - ログレベル（trace, debug, info, warn, error）
  - メッセージ（人間可読な説明）
  - リクエストID（UUID、リクエスト追跡用）
  - コンポーネント（router, node）
  - 追加フィールド（イベント固有の情報）

---

## スコープ外 *(オプション)*

以下の機能は本仕様のスコープ外とし、将来のバージョンで対応予定:

- ログの集中管理（Elasticsearch, Loki等への転送）
- アラート機能（特定のエラーパターン検出時の通知）
- ログのリアルタイムダッシュボード表示
- 分散トレーシング（OpenTelemetry連携）

---

## 技術制約 *(該当する場合)*

- Rust側は既存の `tracing` + `tracing-subscriber` を使用する
- C++側は既存の `spdlog` を使用する
- 新規ライブラリの追加は行わない
- ログ出力先は既存のパス（`~/.llm-router/logs/`）を維持する

---

## 前提条件 *(該当する場合)*

この機能は以下を前提とします:

- ルーターとノードが正常に稼働していること
- ファイルシステムに書き込み権限があること
- 既存のログ設定（環境変数）が維持されること

---

## 依存関係 *(該当する場合)*

この機能は以下に依存します:

- ルーターのOpenAI互換API機能（`router/src/api/openai.rs`）
- ノードの推論エンジン（`node/src/core/inference_engine.cpp`）
- 既存のロギングインフラ（`router/src/logging.rs`, `node/src/utils/logger.cpp`）
- リクエスト履歴機能（SPEC-fbc50d97）

---

## 成功基準 *(必須)*

以下の成功基準を満たす必要があります:

1. 開発者はAPIリクエストの失敗原因を30秒以内にログから特定できる
2. 全てのAPIリクエストが `request_id` で追跡可能である
3. ログの構造がjq等のツールで解析可能なJSON形式である
4. ログ出力によるレスポンスタイムへの影響が1ms以下である
5. 既存のテストが全て合格する

---

## TDD要件 *(必須)*

### テストファースト開発

本機能はTDDで開発する。以下の順序でテストを作成する:

1. **Contract tests**: ログ出力フォーマットの検証
2. **Integration tests**: 実際のリクエストでログが出力されることの検証
3. **Unit tests**: 個別のログ関数のテスト

### テストケース

1. `chat_completions`リクエスト時にINFOログが出力されること
2. ノード選択失敗時にERRORログが出力されること
3. ノード選択失敗時にリクエスト履歴が保存されること
4. ログエントリに必須フィールド（timestamp, level, request_id）が含まれること
5. ストリーミングレスポンス時に開始と完了の両方がログ出力されること

---

## クイックガイドライン

- 既存のtracing/spdlogインフラを活用し、新規ライブラリは導入しない
- ログレベルの適切な使い分け: ERROR(障害), WARN(異常), INFO(イベント), DEBUG(詳細)
- 機密情報のマスキングを徹底
- パフォーマンスへの影響を最小化

---

## 参考資料

- [tracing (Rust)](https://github.com/tokio-rs/tracing) - 構造化ロギング
- [spdlog (C++)](https://github.com/gabime/spdlog) - 高速C++ロギング
- [Logging in Rust (Shuttle)](https://www.shuttle.dev/blog/2023/09/20/logging-in-rust)
- [Top C++ Logging Libraries](https://c-and-beyond.hashnode.dev/top-c-logging-libraries-compared-how-to-choose-the-best-one-part-0)
