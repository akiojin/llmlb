# 技術リサーチ: ヘルスチェックシステム

## リサーチ課題

1. プッシュ型 vs ポーリング型ヘルスチェックの選定
2. 適切なタイムアウトと検出間隔の決定
3. 誤検知（フォールスポジティブ）の最小化
4. 自動復旧メカニズムの設計

## 1. ヘルスチェック方式

### 決定

**プッシュ型ハートビート**

### 理由

- ロードバランサーからのポーリングは1000ノードでスケールしない
- ノード側がネットワーク状態を把握しやすい
- ハートビートにメトリクスを含めて効率化

### 代替案比較表

| 方式 | スケーラビリティ | リアルタイム性 | 実装複雑度 | 採用 |
|------|-----------------|---------------|-----------|------|
| プッシュ型（ハートビート） | 高 | 高 | 低 | ✅ |
| ポーリング型 | 低 | 中 | 低 | × |
| 双方向ヘルスチェック | 中 | 最高 | 高 | × |
| Gossipプロトコル | 最高 | 中 | 高 | × |

### アーキテクチャ

```text
┌──────────────────────────────────────────────────────────┐
│                        Load Balancer                             │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Health Monitor (Background)              │ │
│  │                                                       │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐              │ │
│  │  │ Node 1  │  │ Node 2  │  │ Node 3  │  last_seen   │ │
│  │  │ Online  │  │ Online  │  │ Offline │  tracking    │ │
│  │  └─────────┘  └─────────┘  └─────────┘              │ │
│  └─────────────────────────────────────────────────────┘ │
│                          ▲                                │
└──────────────────────────┼────────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
    ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐
    │   Node 1    │ │   Node 2    │ │   Node 3    │
    │ (heartbeat) │ │ (heartbeat) │ │ (dead)      │
    └─────────────┘ └─────────────┘ └─────────────┘
```

## 2. タイムアウトと検出間隔

### 決定

- **ハートビート間隔**: 30秒
- **タイムアウト**: 60秒（2回分のハートビート）
- **監視間隔**: 10秒（バックグラウンドチェック）

### 理由

- 30秒間隔は負荷とリアルタイム性のバランス
- 60秒タイムアウトで一時的なネットワーク遅延を許容
- 10秒監視で最大10秒以内にオフライン検知

### パラメータ設計

| パラメータ | デフォルト | 環境変数 | 範囲 |
|-----------|-----------|---------|------|
| ハートビート間隔 | 30秒 | `XLLM_HEARTBEAT_SECS` | 10-60秒 |
| タイムアウト | 60秒 | `LLMLB_NODE_TIMEOUT` | 30-300秒 |
| 監視間隔 | 10秒 | `LLMLB_HEALTH_CHECK_INTERVAL` | 5-60秒 |

### 検出時間の計算

```text
最悪ケース検出時間 = ハートビート間隔 + 監視間隔
                    = 30秒 + 10秒 = 40秒

平均検出時間 ≈ (ハートビート間隔 / 2) + 監視間隔
             ≈ 15秒 + 10秒 = 25秒
```

## 3. 誤検知の最小化

### 決定

**タイムアウトベースの単純判定 + 猶予期間**

### 理由

- 複雑な判定ロジックは予期せぬ動作を招く
- 60秒タイムアウトで一時的障害を吸収
- 復旧は即座に行い、ダウンタイムを最小化

### 誤検知シナリオと対策

| シナリオ | 原因 | 対策 |
|----------|------|------|
| 一時的ネットワーク遅延 | パケットロス | 60秒タイムアウトで吸収 |
| ノードの高負荷 | ハートビート遅延 | 非同期送信で軽量化 |
| ロードバランサーの高負荷 | 受信遅延 | last_seen更新は軽量処理 |
| 時刻同期ずれ | NTP問題 | 相対時間（last_seen）を使用 |

### 状態遷移図

```text
                    ┌──────────────┐
                    │   Pending    │←─ ノード登録
                    └──────┬───────┘
                           │ 管理者承認
                           ▼
                    ┌──────────────┐
       ハートビート→│   Online     │←─ ハートビート受信
       受信         └──────┬───────┘
                           │ タイムアウト経過
                           ▼
                    ┌──────────────┐
                    │   Offline    │
                    └──────────────┘
                           │
                           │ ハートビート受信
                           ▼
                    ┌──────────────┐
                    │   Online     │
                    └──────────────┘
```

## 4. 自動復旧メカニズム

### 決定

**ハートビート受信時の即時復帰**

### 理由

- ノードの能動的な復帰通知が最も確実
- 追加のプロービングは複雑性を増す
- シンプルな実装で信頼性を確保

### 復旧フロー

```text
1. ノード再起動
2. ノードがロードバランサーにハートビート送信
3. ロードバランサーがハートビート受信
4. last_seen 更新
5. 状態を Online に変更
6. ロードバランサーの選択対象に追加
7. 次のリクエストから処理可能
```

### 実装ポイント

```rust
// llmlb/src/health.rs
pub async fn handle_heartbeat(
    node_id: &str,
    metrics: NodeMetrics,
) -> Result<()> {
    // 1. メトリクス更新
    registry.update_metrics(node_id, metrics).await?;

    // 2. last_seen 更新
    registry.update_last_seen(node_id).await?;

    // 3. オフラインならオンラインに復帰
    if registry.is_offline(node_id).await? {
        registry.set_online(node_id).await?;
        log::info!("Node {} recovered", node_id);
    }

    Ok(())
}
```

## 参考リソース

- [Consul Health Checks](https://developer.hashicorp.com/consul/docs/services/usage/checks)
- [Kubernetes Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)
- [Netflix Eureka Heartbeats](https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication)
- [CAP Theorem and Failure Detection](https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)
