# 実装計画: モデル自動解決機能

**機能ID**: `SPEC-48678000` | **日付**: 2025-12-06 | **仕様**: [spec.md](./spec.md)
**ステータス**: 計画中

## 概要

モデルがローカルにない場合の自動解決フロー:

1. 共有パスがあれば直接参照
2. 共有パスがアクセス不可なら外部ソース（HF等）またはルータープロキシで取得
3. いずれにもなければエラー

従来のauto_repair（破損検出・修復）機能は削除。外部ソース取得は許可リストで制御する。

## 技術コンテキスト

**言語/バージョン**: C++17, Rust 1.75+
**主要依存関係**: llama.cpp, httplib (C++), reqwest (Rust)
**ストレージ**: ファイルシステム (`~/.llm-router/models/`)
**テスト**: Google Test, cargo test
**対象プラットフォーム**: Windows/macOS
**プロジェクトタイプ**: web (node/, router/)

## 憲章チェック

**シンプルさ**: ✅ 合格

- プロジェクト数: 2 (node, router)
- 明確なフォールバックフロー
- 外部依存は許可リストで限定し、取得経路を明確化

**テスト**: ✅ 合格

- TDD順序: Contract→Integration→E2E→Unit
- モックサーバーでAPI経由テスト

## モデル解決フロー

```text
推論リクエスト受信
    │
    ▼
ローカルキャッシュ確認 ─────────────────┐
    │ 存在する                          │ 存在しない
    ▼                                   ▼
モデルロード                    共有パス確認
                                    │
                    ┌───────────────┴───────────────┐
                    │ アクセス可能                   │ アクセス不可
                    ▼                               ▼
            直接参照（コピーなし）          外部ソース/プロキシ確認
                                                │
                                ┌───────────────┴───────────────┐
                                │ モデル存在                     │ 存在しない
                                ▼                               ▼
                        HTTP経由ダウンロード                  エラー返却
                        ローカルに保存
```

## Phase 2: タスク計画アプローチ

**タスク生成戦略**:

1. auto_repair関連コード削除
2. 共有パス参照ロジック実装
3. 外部ソース/プロキシ経由ダウンロード実装
4. エラーハンドリング強化
5. 統合テスト

**順序戦略**:

- まず削除（auto_repair）
- 次に新規実装（解決フロー）
- 最後に統合テスト

## 進捗トラッキング

**フェーズステータス**:

- [x] Phase 0: Research完了
- [x] Phase 1: Design完了
- [x] Phase 2: Task planning完了
- [ ] Phase 3: Tasks生成済み
- [ ] Phase 4: 実装完了
- [ ] Phase 5: 検証合格

**ゲートステータス**:

- [x] 初期憲章チェック: 合格
- [x] 設計後憲章チェック: 合格
- [x] すべての要明確化解決済み
- [ ] 複雑さの逸脱を文書化済み

---

*憲章 v1.0.0 に基づく - `/memory/constitution.md` 参照*
