# 機能仕様書: llmlb 自動アップデート（承認後に更新して再起動）

**機能ID**: `SPEC-a6e55b37`  
**作成日**: 2026-02-10  
**最終更新日**: 2026-02-23
**ステータス**: 🔄 Phase 2: スケジュール・応答性・ロールバック拡張 (2026-02-23)
**入力**: ユーザー説明: "llmlbの自動アップデートに対応したい。アップデート通知→承認したら更新して再起動。リクエスト処理中はペンディングし、完了後に更新。Ollamaの方式に合わせたい。"

## ユーザーシナリオ＆テスト *(必須)*

### ユーザーストーリー1 - 更新の検知と通知 (優先度: P1)

運用者として、llmlb に新しいバージョンが公開されたら、それを検知してダッシュボードやトレイで通知してほしい。更新の存在に気付けないと、セキュリティ/機能改善を取り逃がすため。

**独立テスト**: GitHub Releases を模擬し、最新タグが現行より新しい場合に `update available` 状態になること。

**受け入れシナリオ**:

1. **前提** 現行 `vA.B.C`、最新 `vX.Y.Z`（X.Y.Z > A.B.C）、**実行** llmlb を起動、**結果** ダッシュボード/トレイに「Update available: vX.Y.Z」が表示される
2. **前提** 最新が現行以下、**実行** llmlb を起動、**結果** 更新通知は表示されない（Up to date）
3. **前提** 更新有無にかかわらず、**実行** ダッシュボードを開く、**結果** ヘッダーに `Current vA.B.C` が常時表示される

---

### ユーザーストーリー2 - 承認したら更新して再起動 (優先度: P1)

運用者として、更新を承認したら、llmlb が自動で更新を適用し再起動してほしい。手動更新は手順ミスや停止時間増につながるため。

**独立テスト**: 承認 API を呼ぶと更新状態が「ドレイン開始」へ遷移すること、適用フェーズで内部アップデータを起動すること。

**受け入れシナリオ**:

1. **前提** 更新が利用可能、**実行** 「Restart to update」を押す、**結果** ドレイン開始→適用→再起動する

---

### ユーザーストーリー3 - リクエスト処理中はペンディング（ドレイン） (優先度: P1)

運用者として、更新承認後に処理中の推論リクエストがある場合は、それらが完了するまで更新を待ってほしい。途中で落ちるとクライアントに障害を与えるため。

**独立テスト**: 推論リクエストが処理中の間は更新が「Draining」のままで、完了した瞬間に適用へ進むこと。

**受け入れシナリオ**:

1. **前提** 推論リクエストが処理中（ストリーミング含む）、**実行** 更新を承認、**結果** 既存リクエストは完走し、完了後に更新が適用される
2. **前提** 更新承認後、**実行** 新規の推論リクエストを送る、**結果** 503（Retry-After付き）で拒否される

---

### ユーザーストーリー4 - OS/インストール形態に応じて適用方法が変わる (優先度: P2)

運用者として、macOS/Windows/Linux の違いや、`.pkg/.msi` インストールと `tar.gz/zip` 展開の違いを意識せずに、可能な範囲で自動更新してほしい。Ollama のように OS ごとに更新方法が変わることは許容する。

**独立テスト**: アセット選定が OS/arch に一致するファイルを選べること。書き込み不可の場合にインストーラ方式へフォールバックすること。

**受け入れシナリオ**:

1. **前提** `tar.gz/zip` 展開で実行中、**実行** 更新承認、**結果** バイナリ置換で更新→再起動する
2. **前提** macOS `.pkg` で `/usr/local/bin/llmlb` 実行中、**実行** 更新承認、**結果** `.pkg` を実行して更新→再起動する（権限が必要ならプロンプトが出る）
3. **前提** Windows `.msi` で Program Files 実行中、**実行** 更新承認、**結果** `.msi` を実行して更新→再起動する（UACが出る）
4. **前提** Linux で書き込み不可のパスに配置、**実行** 更新承認、**結果** 自動適用は失敗し、手動更新の手順が表示される（サービス自体は継続）

---

### ユーザーストーリー5 - 手動チェック導線は常時表示される (優先度: P1)

運用者として、ダッシュボード初期表示や一時的な状態未取得時でも `Check for updates` を使える状態でいてほしい。更新操作の導線が消えると、ページ再読み込みを強いられ運用体験が悪化するため。

**独立テスト**: `update` 状態が未解決の描画時でも Update banner が表示され、`Check for updates` ボタンが存在すること。手動チェック結果が available の場合に、再読み込みなしで `Restart to update` が表示されること。

**受け入れシナリオ**:

1. **前提** ダッシュボード初期描画直後で `systemInfo.update` が未取得、**実行** 画面表示、**結果** Update banner と `Check for updates` ボタンが表示される
2. **前提** 手動チェックが `available` を返す、**実行** `Check for updates` 押下、**結果** 再読み込みなしで `Restart to update` が表示される
3. **前提** 手動チェックが `up_to_date` を返す、**実行** `Check for updates` 押下、**結果** `Restart to update` は表示されず `Up to date` の情報が更新される
4. **前提** 既に `available`（payload ready）を表示中、**実行** 一時的なネットワーク障害下で `Check for updates` 押下、**結果** 既存の `available` 状態は維持され、`Restart to update` の導線は失われない

### ユーザーストーリー6 - ドレイン中のボタンが状態を反映する (優先度: P1)

運用者として、「Restart to update」を押した後にリクエストがドレイン中の場合、ボタンが「Waiting to update... (N)」に変わり押せない状態になってほしい。ボタンが変わらないと、操作が受け付けられたのか判断できないため。

**独立テスト**: `updateState === 'draining'` のとき、ボタンテキストが「Waiting to update... (N)」でdisabledであること。in_flightの値がボタンに反映されること。

**受け入れシナリオ**:

1. **前提** 推論リクエスト3件が処理中、**実行** 「Restart to update」を押す、**結果** ボタンが「Waiting to update... (3)」に変わり、disabled＋スピナー表示
2. **前提** draining中でin_flight=0、**実行** 画面表示、**結果** ボタンが「Waiting to update... (0)」と一瞬表示され、applyingへ遷移
3. **前提** draining中、**実行** 「Check for updates」を確認、**結果** 「Check for updates」もdisabledである
4. **前提** applyUpdate APIが即座適用（queued=false）、**実行** ボタン確認、**結果** 「Waiting to update...」は表示されず、直接「Applying update...」へ遷移

---

### ユーザーストーリー7 - applying中のボタンが適用状態を反映する (優先度: P1)

運用者として、バイナリ置換/インストーラ実行中にボタンが「Applying update...」と表示され、操作不能になってほしい。再起動直前であることを明示し、誤操作を防ぎたいため。

**独立テスト**: `updateState === 'applying'` のとき、ボタンテキストが「Applying update...」でdisabledであること。

**受け入れシナリオ**:

1. **前提** applying状態、**実行** 画面表示、**結果** ボタンが「Applying update...」＋スピナー＋disabled
2. **前提** applying状態、**実行** 「Check for updates」を確認、**結果** disabledである

---

### ユーザーストーリー8 - ヘッダーにアップデート状態バッジ表示 (優先度: P2)

運用者として、ヘッダーの「Current vX.Y.Z」横にアップデート状態を示すドットインジケータとバッジを表示してほしい。バナーをスクロールで見失っても、ヘッダーで状態が把握できるため。

**独立テスト**: `update.state` に応じて、ヘッダーのドット色とバッジテキストが正しく変化すること。

**受け入れシナリオ**:

1. **前提** updateState=up_to_date、**実行** 画面表示、**結果** 緑ドット表示、バッジなし
2. **前提** updateState=available（v2.0.0）、**実行** 画面表示、**結果** 黄色ドット＋「v2.0.0 available」バッジ
3. **前提** updateState=draining、**実行** 画面表示、**結果** 黄色ドット＋「Updating...」バッジ
4. **前提** updateState=applying、**実行** 画面表示、**結果** 黄色ドット＋「Updating...」バッジ
5. **前提** updateState=failed、**実行** 画面表示、**結果** 赤ドット＋「Update failed」バッジ

---

### ユーザーストーリー9 - 強制更新で即時再起動できる (優先度: P1)

運用者として、緊急時には処理中リクエストの完走を待たずに更新を即時適用して再起動したい。セキュリティパッチや重大障害時に、待機よりも復旧速度を優先したいため。

**独立テスト**: 強制更新APIが payload ready の場合に `queued=false` で受理され、`draining` を経由せず適用フェーズへ進むこと。

**受け入れシナリオ**:

1. **前提** updateState=available かつ payload=ready、**実行** `Force update now` を確認して実行、**結果** 進行中リクエストを打ち切って即時再起動処理に入る
2. **前提** updateState=available かつ payload=not_ready、**実行** 強制更新ボタンを確認、**結果** disabled表示となり押下できない
3. **前提** updateStateがavailable以外、**実行** 強制更新ボタンを確認、**結果** ボタン自体は表示されるが disabled かつ「No update is available」説明を表示する
4. **前提** updateState=available かつ payload=ready、**実行** `POST /api/system/update/apply/force`、**結果** `202 Accepted` と `queued=false`、`mode=force` を返す
5. **前提** updateStateがavailable以外またはpayload未準備、**実行** `POST /api/system/update/apply/force`、**結果** `409 Conflict` が返る

---

### ユーザーストーリー10 - Check for updatesが即座に応答する (優先度: P1)

運用者として、「Check for updates」を押したら数秒以内に結果が返ってほしい。現在はGitHub APIチェック＋ペイロードダウンロードを同期的に待つため最悪40秒以上ブロックされ、ボタンがスピナーのまま操作不能になるため。

**独立テスト**: `POST /api/system/update/check` が5秒以内にレスポンスを返すこと。ペイロードのダウンロードはバックグラウンドで行われ、進捗がWebSocketで通知されること。

**受け入れシナリオ**:

1. **前提** ネットワーク正常、**実行** `Check for updates` 押下、**結果** 3秒以内にチェック結果が返り、ボタンのスピナーが解除される
2. **前提** 更新あり、**実行** チェック完了後、**結果** ペイロードDLがバックグラウンドで開始される
3. **前提** ペイロードDL中、**実行** ダッシュボード表示、**結果** DL進捗がプログレスバーで表示される
4. **前提** GitHub APIがタイムアウト、**実行** `Check for updates` 押下、**結果** キャッシュがあれば前回結果を返し、なければエラーメッセージを3秒以内に表示

---

### ユーザーストーリー11 - アップデート予約で3つのモードを選べる (優先度: P1)

運用者として、アップデートの適用タイミングを「即時」「アイドル時」「時刻指定」の3つから選びたい。推論サービスへの影響を最小化するため、業務時間外やリクエストが0のタイミングで自動適用したいため。

**独立テスト**: 各モードで予約を作成し、条件が満たされた時に適用が開始されること。予約情報がJSONファイルに永続化されること。

**受け入れシナリオ**:

1. **前提** 更新あり、**実行** 「即時適用」を選択、**結果** 現行と同じ即時ドレイン→適用フローが開始される
2. **前提** 更新あり＋推論リクエストが3件処理中、**実行** 「アイドル時適用」を選択、**結果** 予約が作成され、リクエストが0になった時点で自動適用が開始される
3. **前提** 更新あり、**実行** 「時刻指定」で明日AM3:00を選択、**結果** 予約が作成され、AM3:00になった時点でドレイン→適用が開始される
4. **前提** 予約作成済み、**実行** llmlbを再起動、**結果** 予約はJSONファイルに永続化されており、再起動後も有効

---

### ユーザーストーリー12 - 予約のキャンセルと二重予約防止 (優先度: P1)

運用者として、予約したアップデートを適用前にキャンセルしたい。また、他の管理者が既に予約している場合はそれを確認したい。誤操作やコンフリクトを防ぐため。

**独立テスト**: 予約キャンセルAPIが予約状態をクリアすること。既に予約が存在する場合に新しい予約がConflictを返すこと。

**受け入れシナリオ**:

1. **前提** 「アイドル時適用」を予約済み、**実行** 「Cancel scheduled update」を押す、**結果** 予約がキャンセルされ、通常状態に戻る
2. **前提** 管理者Aが予約済み、**実行** 管理者BがApplyを押す、**結果** 「管理者Aが〇〇に予約済み」と表示され、409 Conflictが返る
3. **前提** 予約中、**実行** ダッシュボードを開く、**結果** 予約者名・予約時刻・モードがバナーに表示される
4. **前提** 時刻指定で予約中、**実行** 予約時刻が過ぎる前にキャンセル、**結果** 適用されずに予約がクリアされる

---

### ユーザーストーリー13 - アップデート予約の永続化と履歴 (優先度: P1)

運用者として、過去のアップデート履歴（いつ・誰が・どのバージョンへ・成功/失敗）を確認したい。障害時の原因調査や、アップデートパターンの把握に役立つため。

**独立テスト**: アップデート完了/失敗時にJSONファイルに履歴が記録されること。ダッシュボードのアップデート設定モーダルで履歴が表示されること。

**受け入れシナリオ**:

1. **前提** アップデート成功、**実行** 再起動後にアップデート設定を開く、**結果** 前回の更新記録（日時・バージョン・成功・予約者）が表示される
2. **前提** アップデート失敗、**実行** アップデート設定を開く、**結果** 失敗記録（日時・バージョン・失敗理由）が表示される
3. **前提** 複数回のアップデート履歴あり、**実行** 履歴一覧を確認、**結果** 直近10件の履歴が新しい順で表示される

---

### ユーザーストーリー14 - 自動ロールバック（起動失敗検知） (優先度: P1)

運用者として、アップデート後に新バージョンが起動に失敗した場合、自動的に前バージョンに戻してほしい。手動復旧までサービスが停止すると業務影響が大きいため。

**独立テスト**: ヘルパープロセスが新バージョンの起動を監視し、一定時間内に正常応答がなければ`.bak`から復元すること。

**受け入れシナリオ**:

1. **前提** アップデート後の新バージョンが起動クラッシュ、**実行** ヘルパーが監視、**結果** `.bak`ファイルから前バージョンを復元し再起動する
2. **前提** 自動ロールバック実行、**実行** ダッシュボードを開く、**結果** 「Automatic rollback performed」の通知と失敗理由が表示される
3. **前提** 自動ロールバック後、**実行** アップデート履歴を確認、**結果** 「failed (auto-rollback)」として記録されている

---

### ユーザーストーリー15 - 手動ロールバック (優先度: P2)

運用者として、アップデート後に問題が見つかった場合、ダッシュボードから前バージョンに戻したい。新バージョンでの回帰バグ等に対処するため。

**独立テスト**: `.bak`ファイルが存在する場合にロールバックボタンが有効化され、実行で前バージョンに戻ること。

**受け入れシナリオ**:

1. **前提** アップデート直後で`.bak`あり、**実行** 「Rollback to previous version」を押す、**結果** 確認ダイアログ後、前バージョンに戻して再起動する
2. **前提** `.bak`が存在しない、**実行** ロールバックボタンを確認、**結果** disabledで「No previous version available」と表示

---

### ユーザーストーリー16 - ドレインタイムアウト (優先度: P1)

運用者として、ドレインが一定時間以上続いた場合にタイムアウトでキャンセルしたい。無限待機はサービスの可用性を損なうため。

**独立テスト**: ドレイン開始から設定時間を超過した場合に、ドレインがキャンセルされ通常状態に戻ること。

**受け入れシナリオ**:

1. **前提** ドレインタイムアウト=300秒、推論リクエストが5分以上完了しない、**実行** 300秒経過、**結果** ドレインがキャンセルされ、ゲートが再開され、`failed`状態＋「Drain timeout」メッセージが記録される
2. **前提** ドレインタイムアウト中、**実行** ダッシュボード表示、**結果** 残り時間がカウントダウン表示される

---

### ユーザーストーリー17 - viewerロールへの限定表示 (優先度: P2)

viewerロールのユーザーとして、現在のバージョン番号は確認したいが、アップデート操作の導線は不要。誤操作やアクセス権のない操作で混乱したくないため。

**独立テスト**: viewerロールでログインした場合、ヘッダーにバージョン番号が表示され、Update bannerとアップデート操作ボタンが非表示であること。

**受け入れシナリオ**:

1. **前提** viewerロールでログイン、**実行** ダッシュボードを表示、**結果** ヘッダーに `Current vA.B.C` が表示される
2. **前提** viewerロールでログイン、**実行** ダッシュボードを表示、**結果** Update banner・Check for updates・Restart to update・Force updateが非表示

---

### ユーザーストーリー18 - ダウンロード進捗の可視化 (優先度: P2)

運用者として、アップデートペイロードのダウンロード進捗をプログレスバーで確認したい。「Downloading...」のスピナーだけでは進捗が分からず、ハングしているのか進んでいるのか判断できないため。

**独立テスト**: ペイロードDL中にPayloadStateが進捗率を含み、ダッシュボードにプログレスバーが表示されること。

**受け入れシナリオ**:

1. **前提** ペイロードDL中、**実行** ダッシュボード表示、**結果** プログレスバー＋「Downloading: 45MB / 120MB (37%)」が表示される
2. **前提** DL完了、**実行** ダッシュボード表示、**結果** プログレスバーが消え「Payload ready」に遷移

---

### ユーザーストーリー19 - アップデート設定モーダル (優先度: P1)

運用者として、アップデートに関する設定（適用モード選択・時刻指定・予約状態確認・履歴確認）を専用モーダルで一元的に行いたい。バナーのボタン横に全機能を詰め込むとUIが煩雑になるため。

**独立テスト**: Update bannerの「Settings」ボタンからモーダルが開き、各タブ（適用モード・履歴）が機能すること。

**受け入れシナリオ**:

1. **前提** 更新あり、**実行** Update banner の設定アイコンを押す、**結果** アップデート設定モーダルが開く
2. **前提** モーダル内で「アイドル時適用」を選択、**実行** 「Schedule」を押す、**結果** 予約が作成されモーダルが閉じる
3. **前提** モーダルの「履歴」タブを選択、**実行** 表示確認、**結果** 過去のアップデート履歴が表示される

---

## 要件 *(必須)*

### 機能要件

- **FR-001**: システムは GitHub Releases の最新バージョンを検知できる
- **FR-002**: システムは更新が利用可能な場合に、ダッシュボードと（macOS/Windows）トレイで通知する
- **FR-003**: ユーザーが更新を承認した場合、システムは新規推論リクエストを 503 で拒否し、処理中リクエストが完了するまで待機する
- **FR-004**: 処理中リクエストが完了した時点で、システムは更新を適用し再起動する
- **FR-005**: OS/インストール形態に応じて適用方式を切り替える（ポータブル置換 / インストーラ実行 / 手動誘導）
- **FR-006**: システムはダッシュボードヘッダーに、現在実行中バージョン（`/api/system` の `version`）を更新有無に関係なく常時表示する
- **FR-007**: ダッシュボードは `update` 状態が未取得でも Update banner を描画し、`Check for updates` 操作導線を維持する
- **FR-008**: `POST /api/system/update/check` の結果は、ダッシュボード上でページ再読み込みなしに即時反映される
- **FR-009**: `POST /api/system/update/check` が失敗しても、既に `available` で取得済みの更新候補と payload 準備状態は失われない
- **FR-010**: ダッシュボードは `Restart to update` を「更新適用が実行可能な状態」のみで表示する（`available` / `draining` / `applying` / `failed` かつ `latest` が存在）
- **FR-011**: `draining` 状態では適用ボタンのテキストが「Waiting to update... (N)」（Nはin_flight数）に変わり、スピナー表示かつdisabledになる
- **FR-012**: `applying` 状態では適用ボタンのテキストが「Applying update...」に変わり、スピナー表示かつdisabledになる
- **FR-013**: `draining` / `applying` 状態では `Check for updates` ボタンもdisabledになる
- **FR-014**: `applyUpdate` APIレスポンスの `queued=false` の場合、draining表示を経由せず直接applying表示に遷移する
- **FR-015**: ダッシュボードヘッダーの「Current vX.Y.Z」横にアップデート状態を示すドットインジケータ（緑=最新/黄=更新可・更新中/赤=失敗）とバッジテキストを表示する
- **FR-016**: システムは `POST /api/system/update/apply/force` を提供し、payload準備済みのときに強制更新を受け付ける
- **FR-017**: 強制更新は `draining` 状態を経由せず、`applying` に直接遷移する
- **FR-018**: ダッシュボードは通常更新ボタンと強制更新ボタンを分離し、強制更新ボタンは更新候補の有無に関係なく表示する。強制更新には確認ダイアログを表示する
- **FR-019**: 強制更新ボタンは `available` かつ `payload=ready` のときのみ有効化する

### 機能要件 (Phase 2: 応答性・スケジュール・ロールバック)

- **FR-020**: `POST /api/system/update/check` はGitHub APIチェックのみを同期で行い、5秒以内にレスポンスを返す。ペイロードDLはバックグラウンドで行う
- **FR-021**: ペイロードDLの進捗（バイト数/総バイト数/パーセンテージ）をPayloadState経由でAPIとWebSocketに公開する
- **FR-022**: ダッシュボードはペイロードDL中にプログレスバー（バイト数＋パーセンテージ）を表示する
- **FR-023**: システムは3つの適用モードを提供する: 即時（現行）、アイドル時（in_flight=0で自動適用）、時刻指定（cron式で指定時刻に適用）
- **FR-024**: アップデート予約（モード・予約者・予約時刻・対象バージョン）をJSONファイルに永続化する
- **FR-025**: 予約はプロセス再起動後も有効とする（JSONファイルから復元）
- **FR-026**: 既にアップデート予約が存在する場合、新しい予約は `409 Conflict` で拒否し、既存予約の情報（予約者・モード・時刻）を返す
- **FR-027**: 予約のキャンセルAPI（`DELETE /api/system/update/schedule`）を提供し、適用開始前ならいつでもキャンセル可能とする
- **FR-028**: アップデート履歴（日時・from/toバージョン・モード・予約者・結果・失敗理由）をJSONファイルに保存する（直近100件）
- **FR-029**: ヘルパープロセスは新バージョンの起動を監視し、30秒以内にヘルスチェック（`GET /api/version`）に応答しなければ`.bak`から自動復元する
- **FR-030**: 自動ロールバック実行時はアップデート履歴に`failed (auto-rollback)`として記録する
- **FR-031**: ダッシュボードに「Rollback to previous version」ボタンを提供し、`.bak`が存在する場合のみ有効化する
- **FR-032**: ロールバック実行には確認ダイアログを表示する
- **FR-033**: ドレインにタイムアウト（デフォルト300秒）を設け、超過時は適用をキャンセルしゲートを再開する
- **FR-034**: ドレインタイムアウトの残り時間をダッシュボードに表示する
- **FR-035**: viewerロールにはヘッダーのバージョン番号のみ表示し、Update banner・操作ボタンは非表示とする
- **FR-036**: 手動チェック（`POST /api/system/update/check`）にUIスロットリング（最小30秒間隔）を設ける
- **FR-037**: サーバー側で手動チェックのレートリミット（最小60秒間隔）を設け、超過時は `429 Too Many Requests` を返す
- **FR-038**: アップデート設定モーダルを提供し、適用モード選択・時刻指定・予約状態確認・履歴確認を一元化する
- **FR-039**: 予約状態（予約者名・モード・予約時刻）をUpdate bannerとダッシュボードヘッダーに表示する
- **FR-040**: 予約状態をmacOS/Windowsトレイにも通知する（「明日AM3:00に更新予定」等）
- **FR-041**: アイドル時適用モードでは、予約後に初めてin_flight=0になった時点で適用を開始する
- **FR-042**: 時刻指定モードでは、指定時刻到達時にドレイン→適用を開始する（推論リクエスト中であればドレイン処理を実行）

### 非機能要件

- **NFR-001**: 更新チェック/ダウンロードは通常の推論処理をブロックしない（バックグラウンド）
- **NFR-002**: 更新失敗時にサービスを停止させない（状態表示 + 手動誘導）
- **NFR-003**: 更新承認後のドレイン状態は API で観測できる
- **NFR-004**: `POST /api/system/update/check` のレスポンスタイムは5秒以内とする
- **NFR-005**: GitHub APIのレートリミット（60回/時間）を超えない設計とする
- **NFR-006**: 予約情報・履歴はJSONファイルベースで管理し、SQLite依存を追加しない
- **NFR-007**: 自動ロールバックの起動監視は30秒のタイムアウトとする

## 関連仕様

- [SPEC-82cd11b7](../SPEC-82cd11b7/spec.md): API統合リファレンス — 全APIエンドポイントのカタログ・認証モデル分類・設計規約

## スコープ外 *(オプション)*

- 自動でのモデル更新
- 更新ファイルの署名検証・完全なサプライチェーン保証（将来拡張）
- Linux の systemd サービス定義の自動更新（運用者手動）
- 更新チャネル（stable/beta/nightly）の選択機能（将来拡張）
- リリースノートのダッシュボード内埋め込み表示（外部リンクのみ提供）
